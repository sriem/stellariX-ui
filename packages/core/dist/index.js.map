{"version":3,"sources":["../src/index.ts","../src/state.ts","../src/logic.ts","../src/component.ts"],"sourcesContent":["/**\r\n * StellarIX UI Core\r\n * Framework-agnostic implementation of UI components\r\n */\r\n\r\n// Re-export from submodules\r\nexport * from './state';\r\nexport * from './logic';\r\nexport * from './types';\r\nexport * from './component';\r\n\r\n// Version\r\nexport const VERSION = '0.0.1'; ","/**\r\n * State Management System\r\n * Framework-agnostic reactive state management\r\n */\r\n\r\nexport interface Store<T> {\r\n    getState: () => T;\r\n    setState: (updater: T | ((prev: T) => T)) => void;\r\n    subscribe: (listener: (state: T) => void) => () => void;\r\n}\r\n\r\n/**\r\n * Creates a reactive store with the given initial state\r\n * @param initialState The initial state\r\n * @returns A store object with methods to get, set, and subscribe to state\r\n */\r\nexport function createStore<T>(initialState: T): Store<T> {\r\n    let state = initialState;\r\n    const listeners = new Set<(state: T) => void>();\r\n\r\n    const getState = () => state;\r\n\r\n    const setState = (updater: T | ((prev: T) => T)) => {\r\n        state = typeof updater === 'function'\r\n            ? (updater as ((prev: T) => T))(state)\r\n            : updater;\r\n\r\n        listeners.forEach(listener => listener(state));\r\n    };\r\n\r\n    const subscribe = (listener: (state: T) => void) => {\r\n        listeners.add(listener);\r\n        return () => {\r\n            listeners.delete(listener);\r\n        };\r\n    };\r\n\r\n    return {\r\n        getState,\r\n        setState,\r\n        subscribe,\r\n    };\r\n}\r\n\r\n/**\r\n * Creates a derived store based on a selector function\r\n * @param store The source store\r\n * @param selector A function to derive values from the source store\r\n * @returns A store with the derived state\r\n */\r\nexport function createDerivedStore<T, U>(\r\n    store: Store<T>,\r\n    selector: (state: T) => U\r\n): Store<U> {\r\n    const derivedStore = createStore<U>(selector(store.getState()));\r\n\r\n    store.subscribe(state => {\r\n        const newDerivedState = selector(state);\r\n        derivedStore.setState(newDerivedState);\r\n    });\r\n\r\n    return derivedStore;\r\n}\r\n\r\n/**\r\n * Creates a component state store with debugging support\r\n * @param name Component name for debugging\r\n * @param initialState Initial state\r\n * @returns Enhanced store with derive method\r\n */\r\nexport function createComponentState<T>(\r\n    name: string,\r\n    initialState: T\r\n): Store<T> & { derive: <U>(selector: (state: T) => U) => { get: () => U; subscribe: (listener: (value: U) => void) => () => void } } {\r\n    const store = createStore(initialState);\r\n    \r\n    // Add debugging in development\r\n    if (process.env.NODE_ENV === 'development') {\r\n        store.subscribe((state) => {\r\n            console.debug(`[${name}] State updated:`, state);\r\n        });\r\n    }\r\n    \r\n    // Add derive method\r\n    const derive = <U>(selector: (state: T) => U) => {\r\n        let derivedValue = selector(store.getState());\r\n        const derivedListeners = new Set<(value: U) => void>();\r\n        \r\n        store.subscribe((newState) => {\r\n            const newValue = selector(newState);\r\n            if (!Object.is(newValue, derivedValue)) {\r\n                derivedValue = newValue;\r\n                derivedListeners.forEach(listener => listener(derivedValue));\r\n            }\r\n        });\r\n        \r\n        return {\r\n            get: () => derivedValue,\r\n            subscribe: (listener: (value: U) => void) => {\r\n                derivedListeners.add(listener);\r\n                return () => derivedListeners.delete(listener);\r\n            }\r\n        };\r\n    };\r\n    \r\n    return {\r\n        ...store,\r\n        derive\r\n    };\r\n} ","/**\r\n * Logic Layer\r\n * Ultra-generic behavioral logic and accessibility system for any framework\r\n */\r\n\r\nimport type { Store } from './state.js';\r\n\r\n/**\r\n * Ultra-generic logic interface\r\n * Designed to be adaptable to any framework or use case\r\n */\r\nexport interface LogicLayer<TState = any, TEvents extends Record<string, any> = Record<string, any>> {\r\n  handleEvent(event: keyof TEvents | string, payload?: any): void;\r\n  getA11yProps(elementId: string): Record<string, any>;\r\n  getInteractionHandlers(elementId: string): Record<string, Function>;\r\n  initialize(): void;\r\n  cleanup(): void;\r\n  connect(stateStore: Store<TState>): void;\r\n}\r\n\r\n/**\r\n * Event handler function type\r\n */\r\nexport type EventHandler<TState, TPayload = any> = (\r\n  state: TState,\r\n  payload: TPayload\r\n) => Partial<TState> | null | void;\r\n\r\n/**\r\n * Accessibility props generator function type\r\n */\r\nexport type A11yPropsGenerator<TState> = (state: TState) => Record<string, any>;\r\n\r\n/**\r\n * Interaction handler generator function type\r\n */\r\nexport type InteractionHandler<TState> = (\r\n  state: TState,\r\n  event: any\r\n) => string | null;\r\n\r\n/**\r\n * Logic layer configuration\r\n */\r\nexport interface LogicLayerConfig<TState, TEvents> {\r\n  /**\r\n   * Event handlers mapping\r\n   */\r\n  eventHandlers?: {\r\n    [K in keyof TEvents]?: EventHandler<TState, TEvents[K]>;\r\n  };\r\n\r\n  /**\r\n   * Accessibility configuration for elements\r\n   */\r\n  a11yConfig?: {\r\n    [elementId: string]: A11yPropsGenerator<TState>;\r\n  };\r\n\r\n  /**\r\n   * Interaction configuration for elements\r\n   */\r\n  interactionConfig?: {\r\n    [elementId: string]: {\r\n      [eventName: string]: InteractionHandler<TState>;\r\n    };\r\n  };\r\n\r\n  /**\r\n   * Custom initialization logic\r\n   */\r\n  onInitialize?: (stateStore: Store<TState>) => void;\r\n\r\n  /**\r\n   * Custom cleanup logic\r\n   */\r\n  onCleanup?: () => void;\r\n}\r\n\r\n/**\r\n * Creates an ultra-generic logic layer\r\n * Can be adapted to any framework or component system\r\n */\r\nexport function createLogicLayer<\r\n  TState = any,\r\n  TEvents extends Record<string, any> = Record<string, any>\r\n>(\r\n  config: LogicLayerConfig<TState, TEvents> = {}\r\n): LogicLayer<TState, TEvents> {\r\n  let connectedStore: Store<TState> | null = null;\r\n  let isInitialized = false;\r\n\r\n  const {\r\n    eventHandlers = {},\r\n    a11yConfig = {},\r\n    interactionConfig = {},\r\n    onInitialize,\r\n    onCleanup,\r\n  } = config;\r\n\r\n  const handleEvent = (event: string, payload?: any): void => {\r\n    if (!connectedStore) {\r\n      console.warn(`Logic layer not connected. Event \"${event}\" ignored.`);\r\n      return;\r\n    }\r\n\r\n    const handler = (eventHandlers as any)[event];\r\n    if (handler) {\r\n      const currentState = connectedStore.getState();\r\n      const stateUpdate = handler(currentState, payload);\r\n\r\n      if (stateUpdate && typeof stateUpdate === 'object') {\r\n        connectedStore.setState(prev => ({\r\n          ...prev,\r\n          ...stateUpdate,\r\n        }));\r\n      }\r\n    }\r\n  };\r\n\r\n  const getA11yProps = (elementId: string): Record<string, any> => {\r\n    if (!connectedStore) {\r\n      return {};\r\n    }\r\n\r\n    const a11yGenerator = a11yConfig[elementId];\r\n    if (a11yGenerator) {\r\n      return a11yGenerator(connectedStore.getState());\r\n    }\r\n    return {};\r\n  };\r\n\r\n  const getInteractionHandlers = (elementId: string): Record<string, Function> => {\r\n    if (!connectedStore) {\r\n      return {};\r\n    }\r\n\r\n    const elementConfig = interactionConfig[elementId] || {};\r\n    const result: Record<string, Function> = {};\r\n\r\n    Object.entries(elementConfig).forEach(([eventName, eventHandler]) => {\r\n      result[eventName] = (event: any) => {\r\n        if (connectedStore) {\r\n          const eventType = eventHandler(connectedStore.getState(), event);\r\n          if (eventType) {\r\n            handleEvent(eventType, event);\r\n          }\r\n        }\r\n      };\r\n    });\r\n\r\n    return result;\r\n  };\r\n\r\n  const initialize = (): void => {\r\n    if (isInitialized || !connectedStore) {\r\n      return;\r\n    }\r\n\r\n    if (onInitialize) {\r\n      onInitialize(connectedStore);\r\n    }\r\n\r\n    isInitialized = true;\r\n  };\r\n\r\n  const cleanup = (): void => {\r\n    if (!isInitialized) {\r\n      return;\r\n    }\r\n\r\n    if (onCleanup) {\r\n      onCleanup();\r\n    }\r\n\r\n    connectedStore = null;\r\n    isInitialized = false;\r\n  };\r\n\r\n  const connect = (stateStore: Store<TState>): void => {\r\n    if (connectedStore) {\r\n      cleanup();\r\n    }\r\n\r\n    connectedStore = stateStore;\r\n  };\r\n\r\n  return {\r\n    handleEvent,\r\n    getA11yProps,\r\n    getInteractionHandlers,\r\n    initialize,\r\n    cleanup,\r\n    connect,\r\n  };\r\n}\r\n\r\n/**\r\n * Logic layer builder for complex configurations\r\n */\r\nexport class LogicLayerBuilder<TState = any, TEvents extends Record<string, any> = Record<string, any>> {\r\n  private config: LogicLayerConfig<TState, TEvents> = {};\r\n\r\n  /**\r\n   * Add event handler\r\n   */\r\n  onEvent<K extends keyof TEvents>(\r\n    event: K,\r\n    handler: EventHandler<TState, TEvents[K]>\r\n  ): this {\r\n    if (!this.config.eventHandlers) {\r\n      this.config.eventHandlers = {};\r\n    }\r\n    this.config.eventHandlers[event] = handler;\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Add accessibility config for element\r\n   */\r\n  withA11y(elementId: string, generator: A11yPropsGenerator<TState>): this {\r\n    if (!this.config.a11yConfig) {\r\n      this.config.a11yConfig = {};\r\n    }\r\n    this.config.a11yConfig[elementId] = generator;\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Add interaction handler for element\r\n   */\r\n  withInteraction(\r\n    elementId: string,\r\n    eventName: string,\r\n    handler: InteractionHandler<TState>\r\n  ): this {\r\n    if (!this.config.interactionConfig) {\r\n      this.config.interactionConfig = {};\r\n    }\r\n    if (!this.config.interactionConfig[elementId]) {\r\n      this.config.interactionConfig[elementId] = {};\r\n    }\r\n    this.config.interactionConfig[elementId][eventName] = handler;\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Add initialization logic\r\n   */\r\n  onInitialize(callback: (stateStore: Store<TState>) => void): this {\r\n    this.config.onInitialize = callback;\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Add cleanup logic\r\n   */\r\n  onCleanup(callback: () => void): this {\r\n    this.config.onCleanup = callback;\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Build the logic layer\r\n   */\r\n  build(): LogicLayer<TState, TEvents> {\r\n    return createLogicLayer(this.config);\r\n  }\r\n}\r\n\r\n/**\r\n * Legacy compatibility - will be deprecated\r\n * @deprecated Use createLogicLayer instead\r\n */\r\nexport interface LogicLayer_Legacy<StateType, EventsType = Record<string, any>> {\r\n  handleEvent: (event: keyof EventsType, payload?: any) => void;\r\n  getA11yProps: (elementId: string, state: StateType) => Record<string, any>;\r\n  getInteractionHandlers: (elementId: string) => Record<string, (event: any) => void>;\r\n}\r\n\r\n/**\r\n * Component logic configuration for easier component creation\r\n */\r\nexport interface ComponentLogicConfig<TState, TEvents> {\r\n  events?: {\r\n    [K in keyof TEvents]?: (payload: TEvents[K]) => void;\r\n  };\r\n  a11y?: {\r\n    [elementId: string]: (state: TState) => Record<string, any>;\r\n  };\r\n  interactions?: {\r\n    [elementId: string]: (state: TState) => Record<string, Function>;\r\n  };\r\n  onStateChange?: (newState: TState, prevState: TState) => void;\r\n}\r\n\r\n/**\r\n * Creates component logic with a simpler API\r\n * IMPORTANT: This is a simplified wrapper - avoid complex nested subscriptions\r\n */\r\nexport function createComponentLogic<TState, TEvents extends Record<string, any>>(\r\n  _componentName: string,\r\n  config: ComponentLogicConfig<TState, TEvents>\r\n): LogicLayer<TState, TEvents> {\r\n  // Create a simple logic layer without complex subscriptions\r\n  const eventHandlers: any = {};\r\n  const a11yConfig: any = {};\r\n  const interactionConfig: any = {};\r\n  \r\n  // Convert events to handlers\r\n  if (config.events) {\r\n    Object.entries(config.events).forEach(([event, handler]) => {\r\n      eventHandlers[event] = (_state: TState, payload: any) => {\r\n        if (handler) {\r\n          handler(payload);\r\n        }\r\n        return null;\r\n      };\r\n    });\r\n  }\r\n  \r\n  // Set up a11y config\r\n  if (config.a11y) {\r\n    Object.entries(config.a11y).forEach(([elementId, generator]) => {\r\n      a11yConfig[elementId] = generator;\r\n    });\r\n  }\r\n  \r\n  // Set up interaction config - simplified to avoid circular deps\r\n  if (config.interactions) {\r\n    Object.entries(config.interactions).forEach(([elementId, _getHandlers]) => {\r\n      interactionConfig[elementId] = {};\r\n      // We'll populate this when we have state\r\n    });\r\n  }\r\n  \r\n  return createLogicLayer<TState, TEvents>({\r\n    eventHandlers,\r\n    a11yConfig,\r\n    interactionConfig,\r\n    onInitialize: (store) => {\r\n      // Set up interactions with actual state\r\n      if (config.interactions) {\r\n        Object.entries(config.interactions).forEach(([elementId, getHandlers]) => {\r\n          const handlers = getHandlers(store.getState());\r\n          Object.entries(handlers).forEach(([eventName, _handler]) => {\r\n            if (!interactionConfig[elementId]) {\r\n              interactionConfig[elementId] = {};\r\n            }\r\n            interactionConfig[elementId][eventName] = () => eventName;\r\n          });\r\n        });\r\n      }\r\n      \r\n      // Simple state change listener without circular deps\r\n      if (config.onStateChange) {\r\n        let prevState = store.getState();\r\n        const unsubscribe = store.subscribe((newState) => {\r\n          // Add safety check to prevent infinite loops\r\n          if (newState !== prevState) {\r\n            try {\r\n              config.onStateChange!(newState, prevState);\r\n              prevState = newState;\r\n            } catch (error) {\r\n              console.error('Error in onStateChange:', error);\r\n            }\r\n          }\r\n        });\r\n        // Store unsubscribe for cleanup\r\n        (store as any).__logicUnsubscribe = unsubscribe;\r\n      }\r\n    },\r\n    onCleanup: () => {\r\n      // Cleanup any subscriptions\r\n    }\r\n  });\r\n}","/**\r\n * Ultra-Generic Component Factory System\r\n * Enables any framework adapter to be connected to any component\r\n */\r\n\r\nimport { createStore, type Store } from './state.js';\r\nimport type { LogicLayer } from './logic.js';\r\n\r\n/**\r\n * Component metadata for introspection and tooling\r\n */\r\nexport interface ComponentMetadata {\r\n  name: string;\r\n  version: string;\r\n  accessibility: A11yMetadata;\r\n  events: EventMetadata;\r\n  structure: ComponentStructure;\r\n}\r\n\r\n/**\r\n * Accessibility metadata\r\n */\r\nexport interface A11yMetadata {\r\n  role?: string;\r\n  label?: string;\r\n  description?: string;\r\n  keyboardShortcuts?: string[];\r\n  ariaAttributes?: string[];\r\n  wcagLevel: 'A' | 'AA' | 'AAA';\r\n  patterns: string[];\r\n}\r\n\r\n/**\r\n * Event metadata\r\n */\r\nexport interface EventMetadata {\r\n  supported: string[];\r\n  required: string[];\r\n  custom: {\r\n    [eventName: string]: {\r\n      description: string;\r\n      payload?: any;\r\n    };\r\n  };\r\n}\r\n\r\n/**\r\n * Component structure metadata\r\n */\r\nexport interface ComponentStructure {\r\n  elements: {\r\n    [elementId: string]: {\r\n      type: string;\r\n      role?: string;\r\n      optional?: boolean;\r\n    };\r\n  };\r\n  slots?: string[];\r\n  variants?: string[];\r\n  sizes?: string[];\r\n}\r\n\r\n/**\r\n * Framework adapter interface - ultra-minimal for maximum extensibility\r\n */\r\nexport interface FrameworkAdapter<TFrameworkComponent = any> {\r\n  name: string;\r\n  version: string;\r\n  createComponent<TState, TLogic extends Record<string, any> = Record<string, any>>(\r\n    core: ComponentCore<TState, TLogic>\r\n  ): TFrameworkComponent;\r\n  optimize?: (component: TFrameworkComponent) => TFrameworkComponent;\r\n}\r\n\r\n/**\r\n * Ultra-generic component core interface\r\n * This is the heart of the framework-agnostic system\r\n */\r\nexport interface ComponentCore<TState, TLogic extends Record<string, any> = Record<string, any>> {\r\n  state: Store<TState>;\r\n  logic: LogicLayer<TState, TLogic>;\r\n  metadata: ComponentMetadata;\r\n  connect: <TFrameworkComponent>(\r\n    adapter: FrameworkAdapter<TFrameworkComponent>\r\n  ) => TFrameworkComponent;\r\n  destroy: () => void;\r\n}\r\n\r\n/**\r\n * Component factory configuration\r\n */\r\nexport interface ComponentFactoryConfig<TState, TLogic extends Record<string, any>, TOptions> {\r\n  name: string;\r\n  version?: string;\r\n  createInitialState: (options: TOptions) => TState;\r\n  createLogic: (state: Store<TState>, options: TOptions) => LogicLayer<TState, TLogic>;\r\n  metadata: Omit<ComponentMetadata, 'name' | 'version'>;\r\n  onDestroy?: () => void;\r\n}\r\n\r\n/**\r\n * Creates an ultra-generic component factory\r\n * This function is the foundation of the entire component system\r\n */\r\nexport function createComponentFactory<\r\n  TState,\r\n  TLogic extends Record<string, any>,\r\n  TOptions = any\r\n>(\r\n  config: ComponentFactoryConfig<TState, TLogic, TOptions>\r\n): (options?: TOptions) => ComponentCore<TState, TLogic> {\r\n  \r\n  return function componentFactory(options = {} as TOptions): ComponentCore<TState, TLogic> {\r\n    // Create state store with initial state\r\n    const initialState = config.createInitialState(options);\r\n    const state = createStore(initialState);\r\n\r\n    // Create logic layer connected to state\r\n    const logic = config.createLogic(state, options);\r\n    logic.connect(state);\r\n    logic.initialize();\r\n\r\n    // Create component metadata\r\n    const metadata: ComponentMetadata = {\r\n      name: config.name,\r\n      version: config.version || '1.0.0',\r\n      ...config.metadata,\r\n    };\r\n\r\n    // Track connections for cleanup\r\n    const connections = new Set<() => void>();\r\n\r\n    const componentCore: ComponentCore<TState, TLogic> = {\r\n      state,\r\n      logic,\r\n      metadata,\r\n\r\n      /**\r\n       * Connect to any framework adapter\r\n       * This is where the magic happens - one component works with any framework\r\n       */\r\n      connect: <TFrameworkComponent>(\r\n        adapter: FrameworkAdapter<TFrameworkComponent>\r\n      ): TFrameworkComponent => {\r\n        try {\r\n          // Create framework-specific component\r\n          let frameworkComponent = adapter.createComponent(componentCore);\r\n\r\n          // Apply adapter optimization if available\r\n          if (adapter.optimize) {\r\n            frameworkComponent = adapter.optimize(frameworkComponent);\r\n          }\r\n\r\n          // Track connection for cleanup\r\n          connections.add(() => {\r\n            // Cleanup logic can be added here if needed\r\n          });\r\n\r\n          return frameworkComponent;\r\n        } catch (error) {\r\n          throw new Error(\r\n            `Failed to connect ${config.name} to ${adapter.name} adapter: ${(error as Error).message}`\r\n          );\r\n        }\r\n      },\r\n\r\n      /**\r\n       * Clean up component resources\r\n       */\r\n      destroy: () => {\r\n        // Cleanup logic layer\r\n        logic.cleanup();\r\n\r\n        // Cleanup all adapter connections\r\n        connections.forEach(cleanup => cleanup());\r\n        connections.clear();\r\n\r\n        // Run custom cleanup if provided\r\n        if (config.onDestroy) {\r\n          config.onDestroy();\r\n        }\r\n      },\r\n    };\r\n\r\n    return componentCore;\r\n  };\r\n}\r\n\r\n\r\n/**\r\n * Component builder for complex component construction\r\n */\r\nexport class ComponentBuilder<TState = any, TLogic extends Record<string, any> = Record<string, any>, TOptions = any> {\r\n  private config: Partial<ComponentFactoryConfig<TState, TLogic, TOptions>> = {};\r\n\r\n  /**\r\n   * Set component name and version\r\n   */\r\n  withName(name: string, version?: string): this {\r\n    this.config.name = name;\r\n    if (version) this.config.version = version;\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Set initial state creator\r\n   */\r\n  withInitialState(creator: (options: TOptions) => TState): this {\r\n    this.config.createInitialState = creator;\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Set logic creator\r\n   */\r\n  withLogic(creator: (state: Store<TState>, options: TOptions) => LogicLayer<TState, TLogic>): this {\r\n    this.config.createLogic = creator;\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Set component metadata\r\n   */\r\n  withMetadata(metadata: Omit<ComponentMetadata, 'name' | 'version'>): this {\r\n    this.config.metadata = metadata;\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Set cleanup handler\r\n   */\r\n  withCleanup(cleanup: () => void): this {\r\n    this.config.onDestroy = cleanup;\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Build the component factory\r\n   */\r\n  build(): (options?: TOptions) => ComponentCore<TState, TLogic> {\r\n    // Validate required config\r\n    if (!this.config.name) {\r\n      throw new Error('Component name is required');\r\n    }\r\n    if (!this.config.createInitialState) {\r\n      throw new Error('Initial state creator is required');\r\n    }\r\n    if (!this.config.createLogic) {\r\n      throw new Error('Logic creator is required');\r\n    }\r\n    if (!this.config.metadata) {\r\n      throw new Error('Component metadata is required');\r\n    }\r\n\r\n    return createComponentFactory(this.config as ComponentFactoryConfig<TState, TLogic, TOptions>);\r\n  }\r\n}\r\n\r\n/**\r\n * Utility for creating component metadata\r\n */\r\nexport function createComponentMetadata(config: {\r\n  accessibility: Partial<A11yMetadata>;\r\n  events: Partial<EventMetadata>;\r\n  structure: Partial<ComponentStructure>;\r\n}): Omit<ComponentMetadata, 'name' | 'version'> {\r\n  return {\r\n    accessibility: {\r\n      wcagLevel: 'AA',\r\n      patterns: [],\r\n      ...config.accessibility,\r\n    },\r\n    events: {\r\n      supported: [],\r\n      required: [],\r\n      custom: {},\r\n      ...config.events,\r\n    },\r\n    structure: {\r\n      elements: {},\r\n      ...config.structure,\r\n    },\r\n  };\r\n}\r\n\r\n/**\r\n * Type helper for component factory return type\r\n */\r\nexport type ComponentFactory<TState, TLogic extends Record<string, any>, TOptions = any> = \r\n  (options?: TOptions) => ComponentCore<TState, TLogic>;\r\n\r\n/**\r\n * Type helper for extracting state from component core\r\n */\r\nexport type ComponentState<T> = T extends ComponentCore<infer S, any> ? S : never;\r\n\r\n/**\r\n * Type helper for extracting logic from component core\r\n */\r\nexport type ComponentLogic<T> = T extends ComponentCore<any, infer L> ? L : never;\r\n\r\n/**\r\n * Simple function to create a primitive component\r\n * This is a convenience wrapper around ComponentFactoryBuilder\r\n */\r\nexport function createPrimitive<TState, TLogic extends Record<string, any>, TOptions = any>(\r\n  name: string,\r\n  config: {\r\n    initialState: TOptions;\r\n    logicConfig: TOptions;\r\n    metadata: Omit<ComponentMetadata, 'name' | 'version'>;\r\n  }\r\n): ComponentCore<TState, TLogic> {\r\n  // Create a basic component core that will be enhanced later\r\n  const core: ComponentCore<TState, TLogic> = {\r\n    state: {} as any, // Will be set by the implementation\r\n    logic: {} as any, // Will be set by the implementation\r\n    metadata: {\r\n      name,\r\n      version: '0.0.1',\r\n      ...config.metadata\r\n    },\r\n    connect: function<TFrameworkComponent>(\r\n      adapter: FrameworkAdapter<TFrameworkComponent>\r\n    ): TFrameworkComponent {\r\n      return adapter.createComponent(this);\r\n    },\r\n    destroy: () => {\r\n      // Cleanup will be handled by state and logic\r\n    }\r\n  };\r\n  \r\n  return core;\r\n}\r\n\r\n/**\r\n * Type helper for extracting props from component core\r\n */\r\nexport type ComponentProps<T> = T extends ComponentCore<any, any> ? any : never;"],"mappings":"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","names":[]}